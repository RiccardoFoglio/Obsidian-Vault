![[Pasted image 20241120155717.png]]

Data may be stored on disk in different formats to provide efficient query execution: different formats are appropriate for different query needs
Physical access structures describe how data is stored on disk
### Access Method Manager

Transforms an access plan generated by the optimizer into a sequence of physical access requests to (database) disk pages. It exploits access methods 

An access method is a software module. It is specialized for a single physical data structure 
It provides primitives for reading and writing data

Access Method : 
1. Selects the appropriate blocks of a file to be loaded in memory 
2. Requests them to the Buffer Manager 
3. Knows the organization of data into a page, can find specific tuples and values inside a page

Organization of a disk page is different for different access methods. It's divided in:
- space available for data
- space reserved for access method control information
- space reserved for file system control information

Tuples may have varying size: Varchar types Presence of Null values 
A single tuple may span several pages when its size is larger than a single page
# Physical Access Structures

Physical access structures describe how data is stored on disk to provide efficient query execution 
In relational systems
- Physical data storage : Sequential structures / Hash structures 
- Indexing to increase access efficiency : Tree structures (B-Tree, B+-Tree) / Unclustered hash index / Bitmap index
## Sequential Structures : 
- Tuples are stored in a given sequential order 
- Different types of structures implement different ordering criteria 
- Available sequential structures 
	- Heap file (entry sequenced) 
	- Ordered sequential structure
### Heap file : 
- Tuples are sequenced in **insertion order** 
	- insert is typically an **append** at the end of the file 
- **All** the space in a block is completely exploited before starting a new block 
- Delete or update may cause wasted space 
	- Tuple deletion may leave unused space 
	- Updated tuple may not fit if new values have larger size 
- Sequential reading/writing is very efficient 
- Frequently used in relational DBMS 
	- jointly with unclustered (secondary) indices to support search and sort operations
## Ordered Sequential Structures:
- The order in which tuples are written depends on the value of a given key, called sort key 
	- A sort key may contain one or more attributes 
		- the sort key may be the primary key 
- Appropriate for 
	- Sort and group by operations on the sort key 
	- Search operations on the sort key 
	- Join operations on the sort key when sorting is used for join
- Problem : 
	- preserving the sort order when inserting new tuples, it may also hold for update
- Solution :
	- Leaving a percentage of free space in each block during table creation.
	  On insertion, dynamic (re)sorting in main memory of tuples into a block
	- Overflow file containing tuples which do not fit into the correct block

Typically used with $B^+$-Tree clustered (primary) indices : the index key is the sort key : the index key is the sort key.
Used by DBMS to store intermediate operation results
## Tree Structures
Provide “direct” access to data based on the value of a key field 
	The key includes one or more attributes 
It does not constrain the physical position of tuples 
The most widespread in relational DBMS
### General Characteristics
- One root node
- Many intermediate nodes
- Nodes have a large fan-out (each node has many children)
- Leaf nodes provide access to data : Clustered / Unclustered
### $B$-Tree and $B^+$-Tree
2 different tree structures for indexing:
- $B$-Tree : Data pages are reached only through key values by visiting the tree
- $B^+$-Tree : Provides a link structure allowing sequential access in the sort order of key values

B stands for Balanced : Leaves are all at the same distance from the root.
Access time is constant, regardless of the searched value
#### Clustered
The tuple is contained into the leaf node 
	Constrains the physical position of tuples in a given leaf node 
		The position may be modified by splitting the node, when it is full 
	Also called key sequenced 
Typically used for primary key indexing
![[Pasted image 20241121115938.png|500]]
#### Unclustered
The leaf contains physical pointers to actual data 
	The position of tuples in a file is totally unconstrained 
	Also called indirect 
Used for secondary indices
![[Pasted image 20241121120008.png|500]]

Pros:
- efficient for range queries
- appropriate for sequential scan in the order of key field : always for clustered, not guaranteed otherwise

Cons:
- Insertions may require a split of a leaf: possibly also intermediate nodes, computationally intensive
- deletions may require mergine uncrowded nodes and re-balancing
## Hash Structure
It guarantees direct and efficient access to data based on the value of a **key field**. The hash key may include one or more attributes.

Suppose the hash structure has B blocks:
- The hash function is applied to the key field value of a record : It returns a value between 0 and B-1 which defines the position of the record 
- Blocks should never be completely filled to allow new data insertion
![[Pasted image 20241121122239.png]]
Pros:
- Very efficient for queries with equality predicate on the key 
- No sorting of disk blocks is required 
Cons:
- Inefficient for range queries 
- Collisions may occur
### Unclustered Hash Index
- guarantees direct and efficient access to data based on the value of a key field (similar to hash index)
- blocks contain pointers to data : actual data is stored in a separate structure, position of tuples is not constrained to a block (different from hash index)
![[Pasted image 20241121122559.png|500]]
## Bitmap Index
It guarantees direct and efficient access to data based on the value of a key field 
	It is based on a bit matrix 
The bit matrix references data rows by means of RIDs (**R**ow **ID**entifiers) 
	Actual data is stored in a separate structure 
	Position of tuples is not constrained

The bit matrix has one column for each different value of the indexed attribute and one row for each tuple. Position $(i,j)$ of the matrix is : 1 if tuple $i$ takes value $j$, 0 otherwise
![[Pasted image 20241121122929.png|500]]
Pros:
- Very efficient for Boolean expressions of predicates --> Reduced to bit operations on bitmaps 
- Appropriate for attributes with limited domain cardinality
Cons:
- Not used for continuous attributes 
- Required space grows significantly with domain cardinality