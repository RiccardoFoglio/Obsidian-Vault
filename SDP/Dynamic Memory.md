C++ programs can use
- static memory to store static objects, automatically managed by compiler
- stack memory to store non-static objects, duration depends on their scope
- heap memory to store dynamic objects like c++ containers. Heap is needed because allows them to dynamically adjust their size. Container itself is declared on the stack but its internal buffer is allocated on the heap


in C++ we use `New` and `Delete` which correspond to `Malloc` and `free`

### New
allocates a memory block compatible with the type and the sized defined --> to create the object, it calls the constructor of that object
Allocates unnamed objects --> new returns a pointer to that object

2 versions:
- normal : when the requested memory is not available it fires an exception. Never returns a nullptr pointer
- nothrow : returns a nullptr and never fires any exception

Like in C, pointer doesn't know the number of elements to which is pointing to, and the type

### Delete
to avoid memory exhaustion we must return the allocated memory to the system

2 versions of delete
- single for single variables `delete`
- multiple for multiple blocks like vectors `delete[]`


Shallow copy = duplicate the object's memory address not the actual data it points to
```c++
class Box {
public:
	int *v;
	Box (int value) { v = new int(value); }
}

int main(){
	Box box1(10);
	Box box2 = box1;   // shallow copy
	*box2.v = 20;
	std::cout << *box1.v; // output 20
	return 0;
}
```

Deep copy = duplicate the object and alla objects it refers to recursively
```c++
class Box {
public:
	int *v;
	Box (int value) { v = new int(value); }
	Box (const Box &tmp) { v = new int(*tmp.v); }
}

int main(){
	Box box1(10);
	Box box2 = box1;   // shallow copy
	*box2.v = 20;
	std::cout << *box1.v; // output 20
	return 0;
}
```

Managing memory through new and delete is error prone because we have dangling pointers and memory leaks

Dangling Pointer : deleting a pointer makes it invalid but it still points to something.
	generated when memory is released
	may generate memory violations
	are very difficult to discover and trace-back
When initializing a pointer : `int *ptr = nullptr`
When deleting a pointer : `delete ptr; ptr = nulltpr`

Memory Leaks : a dynamic object managed through a built-in pointer exists until it's explicitly deleted. If we forgot to delete the object we have a memory leak. Many programs can't find memory leaks

To avoid these leaks and dangling pointers:
- Use sequential and associative containers
- Use automatic garbage collector

RAII = Resource Acquisition is Initialization
- use smart pointers 
- binds lifetime of a resource to the lifetime of the corresponding object (pointer)
- encapsulate each resource into a class whose unique responsibility is to manage the resource
- defines object with automatic storage duration

3 different types of smart pointers
- shared pointer : allows multiple pointers to refer to the same object
- unique pointer : owns the pointer to which it points
- weak pointer : weak reference to a shared pointer (generated by a shared pointer)

Many operations are similar for all pointers, but some are specific for each

## Shared Pointers
used when a resource may have several owners
multiple pointers may refer to the same resource
Each dynamic resource has a reference count counting the number of pointers referencing it

`new` can be used to allocate shared pointers with 2 disadvantages
- type conversion must be made explicit
- process requires two allocations : first allocate the required memory, second to reserve the space for the control block

Best strategy is to allocated shared pointers with `make_shared`
- allocates and initializes a resource into the heap and returns a shared pointer pointing to it
- It performs a single memory allocation that includes both object and its control block

A shared pointer may be copied and moved
- operations on share pointers are expesive
- should be avoided when possible

![[Screenshot 2025-04-09 at 3.57.26 PM.png|500]]

```c++
#include <memory>
using namespace std;
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(3,9);
```

## Unique Pointers
Introduced in C++11

Unique pointers represent ownership:
- unique pointer owns the object to which it points
- the object is automatically disposed when the unique pointer goes out of scope
- can be moved but not copied
	- useful to obtain a movable handle for an immovable object
	- when used as a function parameter or a return type indicates a transfer of ownership
	- they should almost always be passed by value

```c++
#include<memory>
void my_func() {
	std::unique_ptr<int> valuePtr(new int(15)); // definition and allocation
	...
	if (...)
		return;     // no memory leak
	...             // no memory leak
}

unique_ptr<int> clone1 (int p) {
	return unique_ptr<int>(new int(p));
}

unique_ptr<int> clone2 (int p) {
	unique_ptr<int> lp(new int(p));
	return lp;
}
```

## Weak Pointers

Weak pointers are smart pointers that don't control the lifetime of the object to which they point
weak pointers point to object managed by shared pointers
Creating a weak pointer doesn't change the counter of the original shared pointer

![[Screenshot 2025-04-09 at 4.13.52 PM.png|500]]

Weak pointers can be used to break circular dependency of shared pointers.