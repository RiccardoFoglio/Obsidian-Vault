Multi-threading limitations:
- over-subscription : number of SW threads may be higher than number of HW threads
	- --> To solve these issues C++11 introduced **task-based** parallel programming
- threads don't offer any direct way to return a value to the caller
	- --> To solve these issues C++11 introduced **futures** and **promises**

Task = entity that runs asynchronously producing output data that will become available at a later time
- OS associate thread to a task automatically
- balancing tasks is automatic, through work-stealing features
- tasks have possibility of handling return values

1. Thread-based parallel programming relies on **std::thread** objects
```c++
std::thread t(thread_function);
```
2. task based parallel programming relies on **std::asynch** objects
```c++
auto fut = std::asynch(thread_function);
```

```c++
#include <future>

future<T> async(policy, function, args...);
```

alternative to std::thread to execute functions in parallel, has extra parameter: the policy

- **launch::async** --> asynchronous launch, new thread is generated to run the new function
- **launch::deferred** --> (lazy threading) call to new function is deferred, OS may never run it. It will be run when we wait for it or get its future
- **launch::async | launch::deferred** --> (default policy) run new thread selected by the system accordingly to the availability of concurrency in the system, it's implementation dependent

### Futures

an async object will eventually hold the return value of the thread function in a future
future = object that can represent a value generated by some provide

`<future>::get` applied to a valid future
- blocks thread until object is ready
- returns the object once it is ready

```c++
bool is_prime(int n) {
	if (num <= 1) return false;
	if (num <= 3) return true;
	...
	return false;
}

int main(){
	std::future<bool> fut = std::async(std::launch::async, is_prime, 117);
	// do other work
	bool ret = fut.get();
	cout << ret;
	return 0;
}
```

shared futures: 2 types of futures in C++

- Unique future : only 1 instance referring to the event
- Shared future : object behaves like a future object, except that it can be copied. Multiple instances may refer to the same event. All instances will become ready at the same time and can be retrieved. May be used to signal multiple threads simultaneously, similarly to std::condition_variable::notify_all

### Promises

most common situation: future with a call to an async
- async returns a future
- future represents a value that u don't have yet but will have eventually

at lowest level: future comes from an associated promise:
- object that can store a value to be retrieved by a future object
- when the value is set, it will be made available through its corresponding future

Promise = creates the channel and writes data in the channel
```c++
std::promise<type> pn;
pn.set_value(...);
```

Future = connects to the other end of the channel, waits and reads the data once it has been written
```c++
auto fn = pn.get_future();
fn.get();
```

Main Thread : defines a promise and associates a future to the promise
```c++
std::promise<type> pn;
auto fn = pn.get_future();
```

Working Thread : receive the promise, executes the function and fulfills the promise
```c++
pn.set_value(...);
```

Main thread retrieves the result:
```c++
fn.get();
```

If we destroy the promise without setting a value: exception stored in the object
The object associated to a promise is usually stored in the heap as it cannot be stored
![[Screenshot 2025-05-14 at 2.18.16 PM.png]]


## Conclusions

Task-based approach
- makes OS in charge of Parallelism
- makes the return value of a thread/task accessible
- run threads with a smart policy
	- CPU load balancing
	- Avoid raising of `std::system_error` in case of thread number reached the system limit
- allows futures to catch exceptions thrown by the function
	- with `std::thread()` the program terminates

Thread-based approach
- used to execute tasks that dn't terminate till the end of the application
	- thread entry point function is like a secondo concurrent main
- more general concurrency model
	- can be used for thread-based design patterns
- allows us to access to the pthread native handle
	- makes programmer in charge of parallelism
	- useful for advanced management

# Exercise
Write a program with 3 tasks
- thread **take** reads a number from command line
- thread **check** checks whether that number is prime
- thread **give** displays the answer to standard output

```c++

#include <iotream>
#include <thread>
#include <vector>
#include <future>

void take(std::promise<int>&);
void check(std::future<int>&, std::promise<bool>&);
void give(std::future<bool>&);

int main(){
	std::promise<int> p_in;
	std::future<int> f_in = p_in.get_future();

	std::promise<bool> p_res;
	std::future<bool> f_res = p_res.get_future();

	std::thread t1(take, std::ref(p_in));
	std::thread t2(check, std::ref(f_in), std::ref(p_res));
	std::thread t3(give, std::ref(f_res));

	t1.join();
	t2.join();
	t3.join();

	return 0;
}


void take (std::promise<int> &p_in){
	int in;
	std::cout << "Insert a number" << std::endl;
	std::cin >> inp;
	p_in.set_value(in);
}

void give (std::future<bool>& f_res){
	bool answer - f_res.get();
	std::string s0 (" ");
	if (!answer)
		s0 = "NOT";
	std::out << "Number is" << s0 << "prime";
}

void check (std::future<int>&, std::promise<bool>&){
	int n = f_in.get();
	bool prime = true;
	if (n<=1){
		prime = false;
	}
	// check from 2 to n=1
	for (int j=2; j<n; j++){
		if (n % j == 0){
			prime = false;
			break;
		}
	}
	p_res.set_value(prime);
}
```