One of the main problem in OS is concurrent execution of multiple processes.
Process during IO is waiting, CPU Idle --> maximize idle time to perform other tasks

process = running program, starts when an executable from disk is loaded into memory.

exe file generated from source code.

**Protection**: need to censure that a process can access only those addresses in address space
We can provide the protection by using a pair of base and limit registers that define the logical address space of a process

**Address Binding**: programs on disk ready to be brought into memory to execute from an input queue.
Inconvenient to have first user process physical address always at 0000
Addresses represented in different ways at different stages of a program's life
- Source code: addresses symbolic
- Compiled code: addresses bind to relocatable addresses
- Linker or Loader will bind relocatable addresses to absolute addresses
- Each binding maps one address space to another

Address binding of instructions and data to memory addresses can happen at 3 stages:
- **Compile Time**: if memory location known a priori, absolute code can be generated, must recompile code if starting location changes
- **Load Time**: Must generate relocatable code if memory location is not known at compile time
- **Execution Time**: Binding delayed until run time if the process can be moved during its execution from one memory segment to another (need hardware support for address maps)

## Logical vs Physical Address Space

proper memory management:
- **Logical Address** - Generated by the CPU, also referred to as Virtual Address
- **Physical Address** - address seen by the memory unit

The same in: compile-time, load-time address-binding schemes
They differ in: execution-time address-binding schemes

- Logical address space is the set of all logical addresses generated by a program
- Physical address space is the set of all physical addresses generated by a program

Memory Management Unit (MMU) maps virtual to physical address at run time
base register is called **relocation register**
value is added to every address generated by a user process at the time it is sent to memory
user program deals with logical addresses, never sees real physical addresses
- execution-time binding occurs when reference is made to location in memory
- logical address bound to physical addresses

Dynamic Loading
- entire program doesn't need to be in memory to execute
- routine is not loaded until called
- better memory-space utilization, unused routine is never loaded
- all routines kept on disk in relocatable load format
- useful when large amounts of code are needed to handle infrequently occurring cases
- no special support from the OS is required


Dynamic Linking
- Static Linking: system libraries and program code combined by the loader into the binary program image
- dynamic linking: linking postponed until execution time
- small piece of code, **stub**, used to locate the appropriate memory-resident library routine



# Linking and Loading

what happens to your program after it's compiled, but before it can be run?

EXE files: every OS expects executable files to have a specific format:
- Header info : code locations, data locations
- Code & Data
- Symbol Table : 
	- List of names of things defined in your program and where they are located within your program. 
	- List of names of things defined elsewhere that are used by your program, and where they are used.

Two step operation (in most systems)
- **Linking** : Combining a set of programs including library routines, to create a loadable image
- **Loading** : Copying the loadable image into memory, connecting it with any other programs already loaded, and updating addresses as needed 

![[Screenshot 2025-03-05 at 11.49.25 AM.png|500]]
![[Screenshot 2025-03-05 at 11.49.51 AM.png|500]]

**Classic Unix**
- Linker lives inside of cc or gcc command 
- Loader is part of exec system call
- Executable image contains all object and library modules needed by program 
- Entire image is loaded at once 
- Every image contains its own copy of common library routines 
- Every loaded program contain duplicate copy of library routines

**Dynamic Loading**
- Routine is not loaded until it is called 
- Better memory-space utilization; unused routines are never loaded. 
- Useful when large amounts of code needed to handle infrequently occurring cases.
- Must be implemented through program design 
	- Needs OS support to for loading on demand

**Program-controlled Dynamic Loading**
- load system call to invoke loader (not in classical Unix)
- ability to leave symbols unresolved and resolve at runtime

		void myPrintf(**arg) {
			static int loaded = 0;
			if (!loaded){
				load("printf");
				loaded = 1;
			}
			printf(arg);
		}

**Linker-assisted Dynamic Loading**
Programmer marks modules as "dynamic" to linker
For function call to a dynamic function
- Call is indirect through a link table 
- Each link table entry is initialized with address of small stub of code to locate and load module. 
- When loaded, loader replaces link table entry with address of loaded function
- When unloaded, loader restores table entry with stub address 
- Works only for function calls, not static data

BEFORE vs AFTER
![[Screenshot 2025-03-13 at 2.50.07 PM.png]]
![[Screenshot 2025-03-13 at 2.52.28 PM.png]]


**Shared Libraries**
- "everyone" links to standard libraries. These consume space in every executable image and every process memory at runtime
Would it be possible to share the common libraries? and automatically load them at runtime?
--> libraries designated as "shared" --> .so, /dll etc...
Linker sets up symbols to be resolved at runtime
Loader: is library in memory already?
	yes : map into new process space 
	no : load and then map

**Dynamic Linking**
complete linking postponed until execution time.
Stub used to locate the appropriate memory-resident library routine
stub replaces itself with the address of the routine, and executes the routine
Operating system needs to check if routine is in address space of process
Dynamic linking is particularly useful for libraries

Dynamic Shared Libraries
Static shared libraries require address space pre-allocation
Dynamic shared libraries --> address binding at runtime
	code must be position independent
	at runtime, references are resolved as : library relative address + library base address

### Summary:
Linker = key part of OS, not in Kernel.
- combines object files and libraries into a standard format that the OS loader can interpret
- resolves references and does static relocation of addresses
- Creates information for loader to complete binding process
- Supports dynamic shared libraries

Loader = integral part of OS
- Resolves addresses and symbols that could not be resolved at link-time
- May be small (classic Unix) or large (Linux, Windows)
- May be invoked explicitly (by stub or program itself) or implicitly (as part of exec)

## Contiguous Allocation
- Main memory must support both OS and user processes 
- Limited resource, must allocate efficiently 
- Contiguous allocation is one early method 
- Main memory usually into two partitions: 
	- Resident operating system, usually held in low memory with interrupt vector 
	- User processes then held in high memory 
	- Each process contained in single contiguous section of memory

- Relocation registers used to protect user processes from each other, and from changing operating-system code and data 
	- Base register contains value of smallest physical address 
	- Limit register contains range of logical addresses – each logical address must be less than the limit register 
	- MMU maps logical address dynamically 
	- Can then allow actions such as kernel code being **transient** and kernel changing size
![[Screenshot 2025-03-05 at 12.00.30 PM.png|400]]
## Variable Partition

Multiple-partition allocation 
- Degree of multiprogramming limited by number of partitions 
- **Variable-partition** sizes for efficiency (sized to a given process’ needs)
- **Hole** – block of available memory; holes of various size are scattered throughout memory
- When a process arrives, it is allocated memory from a hole large enough to accommodate it 
- Process exiting frees its partition, adjacent free partitions combined
- Operating system maintains information about: a) allocated partitions b) free partitions (hole)

![[Screenshot 2025-03-05 at 11.59.14 AM.png|500]]

How to satisfy a request of size n from a list of free holes?

- First-fit: Allocate the first hole that is big enough 
- Best-fit: Allocate the smallest hole that is big enough; must search entire list, unless ordered by size 
	- Produces the smallest leftover hole 
- Worst-fit: Allocate the largest hole; must also search entire list 
	- Produces the largest leftover hole 
	
 First-fit and best-fit better than worst-fit in terms of speed and storage utilization

## Fragmentation
**External Fragmentation** – total memory space exists to satisfy a request, but it is not contiguous 
**Internal Fragmentation** – allocated memory may be slightly larger than requested memory; this size difference is memory internal to a partition, but not being used 
First fit analysis reveals that given N blocks allocated, 0.5 N blocks lost to fragmentation 
- 1/3 may be unusable -> 50-percent rule

Reduce external fragmentation by compaction 
- Shuffle memory contents to place all free memory together in one large block 
- Compaction is possible only if relocation is dynamic, and is done at execution time 
- I/O problem 
	- Latch job in memory while it is involved in I/O 
	- Do I/O only into OS buffers
- Now consider that backing store has same fragmentation problems

## Paging

Physical address space of a process can be noncontiguous; process is allocated physical memory whenever the latter is available 
- Avoids external fragmentation 
- Avoids problem of varying sized memory chunks
Divide physical memory into fixed-sized blocks called frames 
- Size is power of 2, between 512 bytes and 16 Mbytes 
Divide logical memory into blocks of same size called pages 
Keep track of all free frames
To run a program of size N pages, need to find N free frames and load program 
Set up a page table to translate logical to physical addresses 
Backing store likewise split into pages 
Still have Internal fragmentation

Address generated by CPU is divided into: 
- Page number (p) – used as an index into a page table which contains base address of each page in physical memory
- Page offset (d) – combined with base address to define the physical memory address that is sent to the memory unit

![[Screenshot 2025-03-05 at 12.25.11 PM.png|400]]
![[Screenshot 2025-03-05 at 12.27.50 PM.png|400]]

![[Screenshot 2025-03-05 at 12.40.30 PM.png|400]]

### Structure of a Page Table Entry
![[Screenshot 2025-03-05 at 12.43.42 PM.png|400]]

## Implementation of Page Table

Page table is kept in main memory 
- Page-table base register (PTBR) points to the page table
- Page-table length register (PTLR) indicates size of the page table
In this scheme every data/instruction access requires two memory accesses 
- One for the page table and one for the data / instruction

The two memory access problem can be solved by the use of a special fast-lookup hardware cache called **translation look-aside buffers** (TLBs) (also called associative memory)

Some TLBs store address-space identifiers (ASIDs) in each TLB entry – uniquely identifies each process to provide address-space protection for that process 
- Otherwise need to flush at every context switch 
TLBs typically small (64 to 1,024 entries) 
On a TLB miss, value is loaded into the TLB for faster access next time 
- Replacement policies must be considered 
- Some entries can be wired down for permanent fast access
![[Screenshot 2025-03-05 at 12.58.12 PM.png|500]]

## Effective Access Time
Hit ratio – percentage of times that a page number is found in the TLB 
An 80% hit ratio means that we find the desired page number in the TLB 80% of the time.
Suppose that 10 nanoseconds to access memory. 
- If we find the desired page in TLB then a mapped-memory access take 10 ns
- Otherwise we need two memory access so it is 20 ns
 Effective Access Time (EAT) EAT = 0.80 x 10 + 0.20 x 20 = 12 nanoseconds implying 20% slowdown in access time 
 Consider amore realistic hit ratio of 99%, EAT = 0.99 x 10 + 0.01 x 20 = 10.1ns implying only 1% slowdown in access time.

## Memory Protection
Memory protection implemented by associating protection bit with each frame to indicate if read-only or read-write access is allowed 
- Can also add more bits to indicate page execute-only, and so on 
Valid-invalid bit attached to each entry in the page table:
- “valid” indicates that the associated page is in the process ’ logical address space, and is thus a legal page 
- “invalid” indicates that the page is not in the process’ logical address space
- Or use page-table length register (PTLR) 
Any violations result in a trap to the kernel

![[Screenshot 2025-03-05 at 1.47.36 PM.png|500]]

## Shared Pages

Shared Code:
- One copy of read-only (reentrant) code shared among processes
- similar to multiple threads sharing the same process space
- also useful to interprocess communication if sharing of read-write pages is allowed
Provate code and data
- Each process keeps a separate copy of the code and data
- The pages for the private code and data can appear anywhere in the logical address space

## Structure of the Page Table

Memory structures for paging can get huge using straight-forward methods 
Consider a 32-bit logical address space as on modern computers 
Page size of 4 KB (212)
Page table would have 1 million entries ($2ˆ{32}$ / $2ˆ{12}$) 
If each entry is 4 bytes è each process 4 MB of physical address space for the page table alone ! Don’t want to allocate that contiguously in main memory
One simple solution is to divide the page table into smaller units ! Hierarchical Paging ! Hashed Page Tables ! Inverted Page Tables

![[Screenshot 2025-03-05 at 2.03.15 PM.png|500]]

### Two-Level Paging

Logical address is divided into:
- page number of 22 bits
- page offset of 10 bits

Since page table is paged, the page number is divided into:
- 10-bit page number
- 12-bit page offset
![[Screenshot 2025-03-13 at 3.14.41 PM.png]]
with:
- p1 = index into the outer page table
- p2 = displacement within the page of the inner table
Known as forward-mapped page table

![[Screenshot 2025-03-13 at 3.15.38 PM.png]]

### 64-bit Logical Address Space

If page size is 4KB (2ˆ12) then page table has 2ˆ52 entries
If two level scheme is used, inner page table could be 2ˆ10 4-byte entries
address would be:

![[Screenshot 2025-03-13 at 3.17.18 PM.png]]

Outer page table has 2ˆ42 entries or 2ˆ44 bytes
One solution is to add a 2nd outer page table, but page table could still be too large --> Three level paging

### Three Level Paging Scheme
![[Screenshot 2025-03-13 at 3.26.52 PM.png]]

### Hashed Page Tables

Common in address spaces > 32 bits 
The virtual page number is hashed into a page table 
- This page table contains a chain of elements hashing to the same location 
Each element contains (1) the virtual page number (2) the value of the mapped page frame (3) a pointer to the next element
Virtual page numbers are compared in this chain searching for a match 
- If a match is found, the corresponding physical frame is extracted
Variation for 64-bit addresses is clustered page tables 
- Similar to hashed but each entry refers to several pages (such as 16) rather than 1
- Especially useful for sparse address spaces (where memory references are non-contiguous and scattered)


![[Screenshot 2025-03-05 at 2.04.34 PM.png|500]]

## Inverted Page Table

Rather than each process having a page table and keeping track of all possible logical pages, track all physical pages 
One entry for each real page of memory 
Entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns that page
Decreases memory needed to store each page table, but increases time needed to search the table when a page reference occurs
Use hash table to limit the search to one — or at most a few — page-table entries
	TLB can accelerate access
But how to implement shared memory? 
	One mapping of a virtual address to the shared physical address
	
![[Screenshot 2025-03-05 at 2.18.58 PM.png|500]]
![[Screenshot 2025-03-05 at 2.21.21 PM.png|500]]

SPARC Solaris 

55/71