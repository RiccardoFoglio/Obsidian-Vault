One of the main problem in OS is concurrent execution of multiple processes.
Process during IO is waiting, CPU Idle --> maximize idle time to perform other tasks

process = running program, starts when an executable from disk is loaded into memory.

exe file generated from source code.

Protection: need to censure that a process can access only those address in address space
We can provide the protection by using a pair of base and limit registers that define the logical address space of a process

Address Binding: programs on disk ready to be brought into memory to execute from an input queue.
Inconvenient to have first user process physical address always at 0000
Addresses represented in different ways at different stages of a program's life
- Source code: addresses symbolic
- Compiled code: addresses bind to relocatable addresses
- Linker or Loader will bind relocatable addresses to absolute addresses
- Each binding maps one address space to another

Address binding of instructions and data to memory addresses can happen at 3 stages:
- Compile Time: if memory location known a priori, absolute code can be generated, must recompile code if starting location changes
- Load Time: Must generate relocatable code if memory location is not known at compile time
- Execution Time: Binding delayed until run time if the process can be moved during its execution from one memory segment to another (need hardware support for address maps)

Logical vs Physical Address Space

proper memory management:
- Logical Address - Generated by the CPU, also referred to as Virtual Address
- Physical Address - address seen by the memory unit

The same in: compile-time, load-time address-binding schemes
They differ in: execution-time address-binding schemes

- Logical address space is the set of all logical addresses generated by a program
- Physical address space is the set of all physical addresses generated by a program

Memory Management Unit (MMU) maps virtual to physical address at run time
base register is called **relocation register**
value is added to every address generated by a user process at the time it is sent to memory
user program deals with logical addresses, never sees real physical addresses
- execution-time binding occurs when reference is made to location in memory
- logical address bound to physical addresses

Dynamic Loading
- entire program doesn't need to be in memory to execute
- routine is not loaded until called
- better memory-space utilization, unused routine is never loaded
- all routines kept on disk in relocatable load format
- useful when large amounts of code are needed to handle infrequently occurring cases
- no special support from the OS is required


Dynamic Linking
- Static Linking: system libraries and program code combined by the loader into the binary program image
- dynamic linking: linking postponed until execution time
- small piece of code, **stub**, used to locate the appropriate memory-resident library routine


(slide 17/71)